#--------------------------------------------------------------------
# walker.rb - IDL typecode and client stubs backend walker
#
# Author: Martin Corino
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the R2CORBA LICENSE which is
# included with this program.
#
# Copyright (c) Remedy IT Expertise BV
#--------------------------------------------------------------------
module IDL
  class RubyWriterBase
    def initialize(output = STDOUT, params = {}, indent = '  ')
      @output = output
      @params = params
      @indent = indent
      @nest = 0
    end

    def print(str);       @output << str; end
    def println(str='');  @output << str << "\n"; end
    def printi(str='');   @output << indent() << str; end
    def printiln(str=''); @output << indent() << str << "\n"; end
    def indent()
      @indent * @nest
    end
    def nest(in_ = 1)
      @nest += in_
      begin
        yield
      ensure
        @nest -= in_
      end
    end

    def visit_nodes(parser)
      pre_visit(parser)

      parser.walk_nodes(self)

      post_visit(parser)
    end
  end

  class RubyStubWriter < RubyWriterBase
    def initialize(output = STDOUT, params = {}, indent = '  ')
      super
    end

    def pre_visit(parser)
      print(
%Q{# -*- Ruby -*-
#
# ****  Code generated by the R2CORBA IDL Compiler ****
# R2CORBA has been developed by:
#        Remedy IT Expertise BV
#        The Netherlands
#        https://www.remedy.nl
#
})
      println("require 'corba'") if @params[:libinit]
      println()
      enter_module(parser.root_namespace) unless parser.root_namespace.nil?
      idleval = @params[:idl_eval] || false
      if !idleval
        printiln("CORBA.implement('#{@params[:idlfile]}', {}, CORBA::IDL::CLIENT_STUB) {")
        println()
      end
    end

    def post_visit(parser)
      idleval = @params[:idl_eval] || false
      if !idleval
        printiln("} ## end of '#{@params[:idlfile]}'")
      end
      leave_module(parser.root_namespace) unless parser.root_namespace.nil?
      println('# -*- END -*-')
    end

    def visit_include(node)
      printiln(format("require '%s'", node.filename.sub(/\.[^\.]*$/, @params[:stub_pfx])))
      println()
    end

    def enter_include(node)
      printiln('## include')
      printiln("CORBA.implement('#{node.filename}', {}, CORBA::IDL::CLIENT_STUB) {")
      println()
    end

    def leave_include(node)
      println()
      printiln("} ## end of include '#{node.filename}'")
      println()
    end

    def enter_module(node)
      printiln('module ' + node.rubyname)
      println()
      @nest += 1
    end
    def leave_module(node)
      @nest -= 1
      printiln("end #of module #{node.rubyname}")
      println()
    end

    def declare_interface(node)
      name = node.rubyname
      if not @params[:class_interfaces].nil? and @params[:class_interfaces].include?(name)
        printiln("class #{name}; end  ## interface forward")
      else
        printiln("module #{name}; end  ## interface forward")
      end
    end
    def enter_interface(node)
      println
      name = node.rubyname
      if node.is_pseudo?
        if not @params[:class_interfaces].nil? and @params[:class_interfaces].include?(name)
          printiln("class #{name}  ## pseudo object interface")
        else
          printiln("module #{name}  ## pseudo object interface")
        end
        @nest += 1
      else
        if not @params[:class_interfaces].nil? and @params[:class_interfaces].include?(name)
          printiln("class #{node.rubyname}  ## interface")
        else
          printiln("module #{node.rubyname}  ## interface")
        end
        println()
        @nest += 1

        if node.bases.size > 0
          node.bases.each do |n|
            printiln("include #{n.scoped_rubyname}")
          end
          println()
        end

        printiln(format("Id = '%s'.freeze", node.repository_id))
        printi('Ids = [ Id')
        if node.is_abstract?
          println(',')
          printi("        'IDL:omg.org/CORBA/AbstractBase:1.0'")
        end
        if node.bases.size > 0
          node.bases.each do |n|
            println(',')
            printi("        #{n.scoped_rubyname}::Id")
          end
        end
        println(' ].freeze')

        println
        unless node.is_abstract?
          printiln(format("def %s._tc; @@tc_%s ||= CORBA::TypeCode::ObjectRef.new(Id, '%s', self); end",
                          node.rubyname, node.rubyname, node.rubyname))
        else
          printiln(format("def %s._tc; @@tc_%s ||= CORBA::TypeCode::AbstractInterface.new(Id, '%s', self); end",
                          node.rubyname, node.rubyname, node.rubyname))
        end
        printiln('self._tc  # register typecode');

        println
        printiln("def #{name}._narrow(obj)")
        nest {
          printiln('return nil if CORBA.is_nil(obj)')
          if node.is_local?
            printiln('return CORBA::Stub.create_stub(obj)._unchecked_narrow!(self)')
          else
            printiln('return CORBA::Stub.create_stub(obj)._narrow!(self)')
          end
        }
        printiln('end')
        println
        printiln("def #{name}._duplicate(obj)")
        nest {
          if node.is_local?
            printiln('obj');
          else
            printiln('return nil if CORBA.is_nil(obj)')
            printiln('return CORBA::Stub.create_stub(super(obj))._narrow!(self)')
          end
        }
        printiln('end')
        println
        printiln('def _interface_repository_id')
        nest {
          printiln("#{node.scoped_rubyname}::Id")
        }
        printiln('end')
      end
      println
    end
    def leave_interface(node)
      name = node.rubyname
      @nest -= 1
      printiln("end #of interface #{name}")
      println
    end

    private
    def print_valuetype_typecode(node)
      if node.is_a?(IDL::AST::Eventtype)
        println("CORBA::TypeCode::Eventtype.new('#{node.repository_id}'.freeze, '#{node.rubyname}',")
      else
        println("CORBA::TypeCode::Valuetype.new('#{node.repository_id}'.freeze, '#{node.rubyname}',")
      end
      nest(3) {
        printi(":#{node.modifier}, ")
        if node.has_concrete_base?
          print("#{node.bases.first.rubyname}._tc")
        else
          print('nil')
        end
        state_members_ = node.state_members
        unless state_members_.empty?
          pfx = '['
          state_members_.each do |m|
            println(',')
            printi(pfx)
            pfx = ''
            if m.has_incomplete_type?
              print("['#{m.rubyname}', ")
              print_valuetype_typecode(m.idltype.resolved_type.node)
              print(", :#{m.visibility}]")
            elsif m.is_recursive?
              print("['#{m.rubyname}', ")
              print("CORBA::TypeCode::Recursive.new('#{m.idltype.resolved_type.node.repository_id}')")
              print(", :#{m.visibility}]")
            else
              print(format("['%s', %s, :%s]", m.rubyname, get_typecode(m.idltype), m.visibility))
            end
          end
          print('], self)')
        else
          print(', self)')
        end
      }
    end

    public

    def declare_valuetype(node)
    end
    def enter_valuetype(node)
      println()
      name = node.rubyname
      unless node.is_abstract?
        printiln("class #{name}")
      else
        printiln("module #{name}")
      end
      @nest += 1

      unless node.is_abstract?
        if node.is_custom?
          printiln('include CORBA::Portable::CustomValueBase')
        else
          printiln('include CORBA::ValueBase')
        end
      else
        printiln('include CORBA::AbstractValueBase')
      end

      unless node.is_abstract?
        trunc_ids = node.truncatable_ids
        println()
        printi('TRUNCATABLE_IDS = [')
        print("'#{trunc_ids.shift}'")
        unless trunc_ids.empty?
          nest {
            trunc_ids.each do |trunc_id|
              println(',')
              printi("'#{trunc_id}'")
            end
          }
        end
        println(' ].freeze')
      end

      println()
      printiln(format('def %s._tc', node.rubyname))
      nest {
        printi("@@tc_#{node.rubyname} ||= ")
        print_valuetype_typecode(node)
        println()
      }
      printiln('end')
      printiln('self._tc  # register typecode')
    end

    def leave_valuetype(node)
      println()
      printiln('module Intf')
      nest {
        intfs_ = node.interfaces
        unless intfs_.empty?
          printiln('## supported interfaces')
          intfs_.each do |intf|
            printiln("include #{intf.scoped_rubyname}")
          end
          printiln('undef :_interface_repository_id')
        end

        bases_ = Array.new(node.bases)
        if node.has_concrete_base?
          printiln('## concrete base type')
          printiln("include #{bases_.shift.scoped_rubyname}::Intf")
        end
        unless bases_.empty?
          printiln('## abstract base types')
          bases_.each do |base|
            printiln("include #{base.scoped_rubyname}::Intf")
          end
        end

        if node.has_concrete_base?() || !bases_.empty?() || !intfs_.empty?()
          println
        end

        intf_members_ = node.interface_members
        [IDL::AST::Operation, IDL::AST::Attribute].each do |m_type|
          has_type = false
          intf_members_.each do |m|
            if m.is_a?(m_type)
              if m.is_a?(IDL::AST::Operation)
                printi('## operations') unless has_type
                visit_operation(m)
                has_type = true
              else
                printi('## attributes') unless has_type
                visit_attribute(m)
                has_type = true
              end
            end
          end
          println() if has_type
        end

        unless node.is_abstract?
          state_members_ = node.state_members
          has_type = false
          state_members_.each do |m|
            if m.visibility == :public
              printiln('## public value state') unless has_type
              printiln(format('attr_accessor :%s', m.rubyname))
              has_type = true
            end
          end
          println() if has_type
          has_type = false
          state_members_.each do |m|
            unless m.visibility == :public
              unless has_type
                printiln('## private value state')
                printiln('protected')
              end
              printiln(format('attr_accessor :%s', m.rubyname))
              has_type = true
            end
          end
          println() if has_type

          printiln('public')
          println()

          unless node.is_custom?
            printiln('def self.marshal(vt, __os__)')
            nest {
              printiln("#{node.bases.first.scoped_rubyname}::Intf.marshal(vt, __os__)") if node.has_concrete_base?
              unless state_members_.empty?
                printiln('vt._marshal_with(__os__) do')
                nest {
                  state_members_.each_with_index do |m, i|
                    printiln("__os__.write_member(#{node.scoped_rubyname}._tc.member_type(#{i}),")
                    printiln("                    self.#{m.rubyname})")
                  end
                }
                printiln('end')
              end
            }
            printiln('end')
            println()

            printiln('def self.unmarshal(vt, __is__)')
            nest {
              printiln("#{node.bases.first.scoped_rubyname}::Intf.unmarshal(vt, __is__)") if node.has_concrete_base?
              unless state_members_.empty?
                printiln('vt._unmarshal_with(__is__) do')
                nest {
                  state_members_.each_with_index do |m, i|
                    printi("self.#{m.rubyname} = ")
                    println("__is__.read_member(#{node.scoped_rubyname}._tc.member_type(#{i}))")
                  end
                }
                printiln('end')
              end
            }
            printiln('end')
            println()

            printiln('def marshal(os)')
            nest {
              printiln("#{node.scoped_rubyname}::Intf.marshal(self, os)")
            }
            printiln('end')
            println()

            printiln('def unmarshal(is)')
            nest {
              printiln("#{node.scoped_rubyname}::Intf.unmarshal(self, is)")
            }
            printiln('end')
            println()
          end
        end
      }
      printiln('end # of Intf')
      println
      printiln('include Intf')
      println

      @nest -= 1
      if node.is_a?(IDL::AST::Eventtype)
        printiln("end #of eventtype #{node.rubyname}")
      else
        printiln("end #of valuetype #{node.rubyname}")
      end

      unless node.is_abstract?
        println
        initializers = node.initializers
        printiln("class #{node.rubyname}Factory < CORBA::Portable::ValueFactoryBase")
        nest {
          printiln("VALUE_ID = '#{node.repository_id}'.freeze")
          if initializers.empty?
            unless node.has_operations_or_attributes?(false)
              # valuetype has only state, create the default factory
              printiln('def _create_default')
              nest {
                printiln("#{node.scoped_rubyname}.new")
              }
              printiln('end')
            end
          else
            println()
            initializers.each do |init|
              printiln("def #{init.rubyname}(#{init.params().collect {|p| p.rubyname}.join(',')})")
              nest {
                printiln("raise RuntimeError, 'unimplemented local operation called'")
              }
              printiln('end')
            end
          end
        }
        printiln("end # of #{node.rubyname}Factory")
      end
    end

    def visit_valuebox(node)
      println
      name = node.rubyname
      printiln("class #{name}")
      nest {
        printiln('include CORBA::Portable::BoxedValueBase')
        println()
        printiln("TRUNCATABLE_IDS = [ '#{node.repository_id}' ].freeze")
        println()
        printiln(format('def %s._tc', node.rubyname))
        nest {
          printiln(format("@@tc_%s ||= CORBA::TypeCode::Valuebox.new('%s'.freeze, '%s',",
                          node.rubyname, node.repository_id, node.rubyname))
          printiln("   #{get_typecode(node.boxed_type)}, self)")
        }
        printiln('end')
        printiln('self._tc  # register typecode');
        printiln('attr_accessor :value')
        printiln('def initialize(val = nil); @value = val; end')
      }
      printiln("end #of valuebox #{name}")
      println
    end

    def visit_const(node)
      #v = Expression::Value.new(node.idltype, node.value)
      s = node.rubyname + ' = ' + expression_to_s(node.expression)
      printiln(s)
    end

    def visit_operation(node, from_valuetype=false)
      _parm = node.params
      _in = node.in_params
      _out = node.out_params
      _intf = node.enclosure

      println()
      printi("def #{node.rubyname}(")
      print(_in.collect{ |p| p.rubyname }.join(', '))
      if node.oneway
        println(')    # oneway')
      else
        println(')')
      end

      nest do
        if _intf.is_a?(IDL::AST::Valuetype) or from_valuetype
          printiln("raise RuntimeError, 'unimplemented local operation called'")
        elsif _intf.is_local?
          printiln('raise ::CORBA::NO_IMPLEMENT.new(')
          printiln("         'unimplemented operation on local interface',")
          printiln('         1, ::CORBA::COMPLETED_NO)')
        else
          ## check if this is a proper object reference
          printiln('raise ::CORBA::NO_IMPLEMENT unless self.respond_to?(:_invoke, true)')

          ##  validate data for IN/INOUT args
          ##
          if _parm.size > 0
            _parm.each do |p|
              if p.attribute != IDL::AST::Parameter::OUT
                printiln("#{p.rubyname} = #{get_typecode(p.idltype)}.validate(#{p.rubyname})")
              end
            end
          end

          ##  invoke operation
          ##
          if not node.oneway
            printi("_ret = self._invoke('#{node.name}', {")
          else
            printi("self._invoke('#{node.name}', {")
          end

          newln = ''
          if _parm.size > 0
            println(newln)
            nest do
              printi(':arg_list => [')
              nest {
                pfx = ''
                _parm.each do |p|
                  println(pfx)
                  printi("['#{p.rubyname}', #{get_arg_type(p.attribute)}, ");
                  print(get_typecode(p.idltype))
                  if p.attribute != IDL::AST::Parameter::OUT
                    print(", #{p.rubyname}]")
                  else
                    print(']')
                  end
                  pfx = ','
                end
                print(']')
              }
            end
            newln = ','
          end

          if not node.oneway
            println(newln)
            nest { printi(":result_type => #{get_typecode(node.idltype)}") }
            newln = ','
          end

          if node.raises.size > 0
            println(newln)
            nest {
              printi(':exc_list => [')
              pfx = ''
              nest {
                node.raises.each { |ex|
                  println(pfx)
                  pfx = ','
                  printi(get_typecode(ex))
                }
                print(']')
              }
            }
          end

          println('})')

          if not node.oneway
            returns_void = (node.idltype.is_a? Type::Void)
            size = _out.size
            size += 1 unless returns_void
            printiln('_ret')
          end
        end
      end

      printiln("end #of operation #{node.rubyname}")
    end

    def visit_attribute(node, from_valuetype=false)
      _intf = node.enclosure
      println()
      printiln("def #{node.rubyname}()")
      nest do
        if _intf.is_a?(IDL::AST::Valuetype) or from_valuetype
          printiln("@#{node.name}")
        elsif _intf.is_local?
          printiln('raise ::CORBA::NO_IMPLEMENT.new(')
          printiln("         'unimplemented attribute on local interface',")
          printiln('         1, ::CORBA::COMPLETED_NO)')
        else
          ## check if this is a proper object reference
          printiln('raise ::CORBA::NO_IMPLEMENT unless self.respond_to?(:_invoke, true)')

          printiln("_ret = self._invoke('_get_#{node.name}', {")
          nest { printi(":result_type => #{get_typecode(node.idltype)}") }
          if node.get_raises.size > 0
            println(',')
            nest {
              printi(':exc_list => [')
              pfx = ''
              nest {
                node.get_raises.each { |ex|
                  println(pfx)
                  pfx = ','
                  printi(get_typecode(ex))
                }
                print(']')
              }
            }
          end
          println('})')

          printiln('_ret')
        end
      end
      printiln("end #of attribute #{node.name} getter")
      if not node.readonly
        printiln("def #{node.rubyname}=(val)")
        nest do
          if _intf.is_a?(IDL::AST::Valuetype) or from_valuetype
            printiln("@#{node.name} = val")
          elsif _intf.is_local?
            printiln('raise ::CORBA::NO_IMPLEMENT.new(')
            printiln("         'unimplemented attribute on local interface',")
            printiln('         1, ::CORBA::COMPLETED_NO)')
          else
            ## check if this is a proper object reference
            printiln('raise ::CORBA::NO_IMPLEMENT unless self.respond_to?(:_invoke, true)')

            ## validate IN arg
            printiln("val = #{get_typecode(node.idltype)}.validate(val)")
            ## invoke operation
            printiln("self._invoke('_set_#{node.name}', {")
            nest {
              printiln(':arg_list => [')
              nest {
                printiln("['val', CORBA::ARG_IN, #{get_typecode(node.idltype)}, val]],");
              }
              printi(':result_type => CORBA._tc_void')
              if node.set_raises.size > 0
                println(',')
                printi(':exc_list => [')
                pfx = ''
                nest {
                  node.set_raises.each { |ex|
                    println(pfx)
                    pfx = ','
                    printi(get_typecode(ex))
                  }
                  print(']')
                }
              end
              println('})')
            }
          end
        end
        printiln("end #of attribute #{node.name} setter")
      end
    end

    def get_typecode(_type)
      case _type
      when Type::Octet,
           Type::UShort, Type::Short,
           Type::ULong, Type::Long,
           Type::ULongLong, Type::LongLong,
           Type::Boolean, Type::Char, Type::WChar,
           Type::Float, Type::Double, Type::LongDouble,
           Type::Void, Type::Any
        s = _type.class.name.split('::') # IDL::Type::Octet -> [IDL, Type, Octet]
        s = s[s.length - 1]
        s.downcase!
        format('CORBA._tc_%s', s)

      when Type::Object
        'CORBA._tc_Object'

      when Type::String
        if not _type.length.nil?
          format('CORBA::TypeCode::String.new(%d)', _type.length)
        else
          'CORBA._tc_string'
        end

      when Type::WString
        if not _type.length.nil?
          format('CORBA::TypeCode::WString.new(%d)', _type.length)
        else
          'CORBA._tc_wstring'
        end

      when Type::ScopedName
        scoped_type = _type.node.idltype
        if scoped_type.is_a?(IDL::Type::Interface) && scoped_type.node.is_forward?()
          node = scoped_type.node
          "(CORBA::TypeCode.typecode_for_id('#{node.repository_id}') || " +
            "CORBA::TypeCode::ObjectRef.new('#{node.repository_id}', '#{node.rubyname}', #{node.scoped_rubyname}))"
        else
          _type.node.scoped_rubyname + '._tc'
        end

      when Type::Array
        sep = ''
        tc = 'CORBA::TypeCode::Array.new(' +
            get_typecode(_type.basetype) + ', '
        _type.sizes.each do |sz|
          tc += "#{sep}#{sz.to_s}"
          sep = ', '
        end
        tc + ')'

      when Type::Sequence
        if _type.is_recursive?
          "CORBA::TypeCode::Sequence.new(CORBA::TypeCode::Recursive.new('#{_type.basetype.resolved_type.node.repository_id}'))"
        else
          'CORBA::TypeCode::Sequence.new(' +
                get_typecode(_type.basetype) +
                if not _type.length.nil? then format(', %d)', _type.length) else ')' end
        end

      else
        raise "invalid type for (un)marshalling: #{_type.typename}"
      end
    end

    def get_arg_type(_idl_argtype)
      case _idl_argtype
      when IDL::AST::Parameter::IN
        'CORBA::ARG_IN'
      when IDL::AST::Parameter::OUT
        'CORBA::ARG_OUT'
      else
        'CORBA::ARG_INOUT'
      end
    end

    def expression_to_s(exp)
      case exp
      when Expression::Value
        value_to_s(exp)
      when Expression::Operation
        operation_to_s(exp)
      when Expression::ScopedName, Expression::Enumerator
        exp.node.scoped_rubyname
      else
        raise "unknown expression type: #{exp.class.name}"
      end
    end

    def value_to_s(exp)
      s = nil
      v = exp.value
      case exp.idltype
      when Type::Void
        s = 'nil'
      when Type::Char
        s = "'#{v.chr}'"
      when Type::Integer,
        Type::Boolean,
        Type::Octet,
        Type::Float
        s = v.to_s
      when Type::WChar
        s = (case v.first
        when :char, :esc_ch
          v.last.unpack('c')
        when :esc
          IDL::Scanner::ESCTBL[v.last]
        when :oct
          v.last.oct
        when :hex2, :hex4
          v.last.hex
        else
          0
        end).to_s
      when Type::Enum
        v = exp.idltype.narrow(v)
        s = exp.idltype.node.enumerators[v].scoped_rubyname
      when Type::String
        s = "'#{v.to_s}'"
      when Type::WString
        v = (v.collect do |(elt, elv)|
          case elt
          when :char, :esc_ch
            elv.unpack('c')
          when :esc
            IDL::Scanner::ESCTBL[elv]
          when :oct
            elv.oct
          when :hex2, :hex4
            elv.hex
          else
            nil
          end
        end).compact
        s = "[#{v.join(',')}]"
      #when Type::Fixed
      #when Type::Any
      #when Type::Object
      when Type::ScopedName
        s = value_to_s(Expression::Value.new(exp.idltype.node.idltype, v))
      else
        raise "#{exp.typename}'s not been supported yet."
      end
      s
    end

    def operation_to_s(exp)
      s = nil
      op = exp.operands
      case exp
      when Expression::Operation::UnaryPlus
        s = expression_to_s(op[0])
      when Expression::Operation::UnaryMinus
        s = '-' + expression_to_s(op[0])
      when Expression::Operation::UnaryNot
        s = '~' + expression_to_s(op[0])
      when Expression::Operation::Or
        s = expression_to_s(op[0]) + ' | ' + expression_to_s(op[1])
      when Expression::Operation::And
        s = expression_to_s(op[0]) + ' & ' + expression_to_s(op[1])
      when Expression::Operation::LShift
        s = expression_to_s(op[0]) + ' << ' + expression_to_s(op[1])
      when Expression::Operation::RShift
        s = expression_to_s(op[0]) + ' >> ' + expression_to_s(op[1])
      when Expression::Operation::Add
        s = expression_to_s(op[0]) + ' + ' + expression_to_s(op[1])
      when Expression::Operation::Minus
        s = expression_to_s(op[0]) + ' - ' + expression_to_s(op[1])
      when Expression::Operation::Mult
        s = expression_to_s(op[0]) + ' * ' + expression_to_s(op[1])
      when Expression::Operation::Div
        s = expression_to_s(op[0]) + ' / ' + expression_to_s(op[1])
      when Expression::Operation::Mod
        s = expression_to_s(op[0]) + ' % ' + expression_to_s(op[1])
      else
        raise "unknown operation: #{exp.type.name}"
      end
      '(' + s + ')'
    end

    def declare_struct(node)
    end
    def enter_struct(node)
      println()
      name = node.rubyname
      printiln("class #{name} < CORBA::Portable::Struct")
      @nest += 1
    end
    def leave_struct(node)
      tc_ = if node.is_a? IDL::AST::Exception then 'Except' else 'Struct' end
      println()
      printiln(format('def %s._tc', node.rubyname))
      struct_members_ = node.members
      nest {
        printi(format("@@tc_%s ||= CORBA::TypeCode::%s.new('%s'.freeze, '%s'",
                      node.rubyname, tc_, node.repository_id, node.rubyname))
        unless struct_members_.empty?
          pfx = '   ['
          struct_members_.each do |m|
            println(',')
            printi(pfx)
            pfx = '    '
            print(format("['%s', %s]", m.rubyname, get_typecode(m.idltype)))
          end
          println('], self)')
        else
          println(', self)')
        end
      }
      printiln('end')
      printiln('self._tc  # register typecode');
      struct_members_.each do |m|
        printiln(format('attr_accessor :%s', m.rubyname))
      end

      if struct_members_.size > 0
        printiln('def initialize(*param_)')
        nest {
          struct_members_.each do |m|
            printiln("@#{m.rubyname} = param_.shift")
          end
        }
        printiln('end')
        println()
      end

      name = node.rubyname
      @nest -= 1
      printiln("end #of #{if node.is_a? IDL::AST::Exception then "exception" else "struct" end} #{name}")
    end

    def enter_exception(node)
      println()
      name = node.rubyname
      printiln("class #{name} < CORBA::UserException")
      @nest += 1
    end
    def leave_exception(node)
      leave_struct(node)
    end

    def declare_union(node)
    end
    def enter_union(node)
      println()
      name = node.rubyname
      printiln("class #{name} < CORBA::Portable::Union")
      @nest += 1
    end
    def leave_union(node)
      println()
      printiln(format('def %s._tc', node.rubyname))
      nest {
        printiln(format("@@tc_%s ||= CORBA::TypeCode::Union.new('%s'.freeze, '%s',",
                      node.rubyname, node.repository_id, node.rubyname))
        printi("    #{get_typecode(node.switchtype)}")
        if node.members.size > 0
          pfx = '   ['
          node.members.each do |m|
            m.labels.each do |lbl|
              println(',')
              printi(pfx)
              pfx = '    '
              labeltxt = if lbl == :default then ':default'; else expression_to_s(lbl); end
              print(format("[%s, '%s', %s]", labeltxt, m.rubyname, get_typecode(m.idltype)))
            end
          end
          print('], self')
        else
          print(', self')
        end
        if (!node.has_default?) && node.default_label # has implicit default?
          println(", #{expression_to_s(node.default_label)})")
        else
          println(')')
        end
      }
      printiln('end')
      printiln('self._tc  # register typecode');
      ix = 0
      if node.members.size > 0
        node.members.each do |m|
          printiln(format('def %s; @value; end', m.rubyname))
          printiln(format('def %s=(val); _set_value(%d, val); end', m.rubyname, ix))
          ix += m.labels.size
        end
      end

      if (!node.has_default?) && node.default_label # has implicit default?
        def_label = expression_to_s(node.default_label)
        printiln("def _default; @discriminator = #{def_label}; @value = nil; end")
      end

      name = node.rubyname
      @nest -= 1
      printiln("end #of union #{name}")
    end

    def visit_enum(node)
      printiln(format('class %s < ::R2CORBA::FIXNUM_KLASS', node.rubyname))
      nest {
        printiln(format('def %s._tc', node.rubyname))
        nest {
          printi(format("@@tc_%s ||= CORBA::TypeCode::Enum.new('%s'.freeze, '%s', [",
                        node.rubyname, node.repository_id, node.rubyname))
          pfx = ''
          node.enumerators.each { |e|
            println(pfx)
            pfx = ','
            printi("    '#{e.rubyname}'")
          }
          println('])')
        }
        printiln('end')
        printiln('self._tc  # register typecode');
      }
      printiln(format('end # enum %s', node.rubyname))
    end

    def visit_enumerator(node)
      v = Expression::Value.new(node.idltype, node.value)
      s = node.rubyname + ' = ' + expression_to_s(v)
      printiln(s)
    end

    def visit_typedef(node)
      #tc_ = node.enclosure.rubyname + '._tc_' + node.rubyname
      #typ_ = node.enclosure.rubyname + '.' + node.rubyname
      case t = node.idltype
      when Type::ScopedName
        if Type::Interface === t.resolved_type
          printiln(format('%s = %s # typedef %s', node.rubyname, t.node.scoped_rubyname, node.rubyname))
        else
          printiln(format('class %s < %s', node.rubyname, t.node.scoped_rubyname))
          nest {
            printi(format('def %s._tc; ', node.rubyname))
            print(format("@@tc_%s ||= CORBA::TypeCode::Alias.new('%s', '%s',", node.rubyname, node.repository_id, node.rubyname))
            println(format('%s, self); end', get_typecode(t)))
          }
          printiln(format('end # typedef %s', node.rubyname))
        end

      when IDL::Type::Native
        printiln("class #{node.rubyname}; end  ## 'native' type");

      when Type::Any, Type::Octet,
          Type::UShort, Type::Short,
          Type::ULong, Type::Long,
          Type::ULongLong, Type::LongLong,
          Type::Boolean, Type::Char, Type::WChar,
          Type::Float, Type::Double, Type::LongDouble
        s = t.class.name.split('::') # IDL::Type::Octet -> [IDL, Type, Octet]
        s = s[s.length - 1]
        s.downcase!
        printiln(format('class %s < CORBA::_tc_%s.get_type', node.rubyname, s))
        nest {
          printiln(format("def %s._tc; @@tc_%s ||= CORBA::TypeCode::Alias.new('%s', '%s', CORBA::_tc_%s, self); end",
                          node.rubyname, node.rubyname, node.repository_id, node.rubyname, s))
        }
        printiln(format('end # typedef %s', node.rubyname))

      when Type::String
        printiln(format('class %s < String', node.rubyname))
        nest {
          if not t.length.nil?
            printiln(format("def %s._tc; @@tc_%s ||= CORBA::TypeCode::Alias.new('%s', '%s', CORBA::TypeCode::String.new(%d), self); end",
                            node.rubyname, node.rubyname, node.repository_id, node.rubyname, t.length))
          else
            printiln(format("def %s._tc; @@tc_%s ||= CORBA::TypeCode::Alias.new('%s', '%s', CORBA::_tc_string, self); end",
                            node.rubyname, node.rubyname, node.repository_id, node.rubyname))
          end
        }
        printiln(format('end # typedef %s', node.rubyname))

      when Type::WString
        printiln(format('class %s < Array', node.rubyname))
        nest {
          if not t.length.nil?
            printiln(format("def %s._tc; @@tc_%s ||= CORBA::TypeCode::Alias.new('%s', '%s', CORBA::TypeCode::WString.new(%d), self); end",
                            node.rubyname, node.rubyname, node.repository_id, node.rubyname, t.length))
          else
            printiln(format("def %s._tc; @@tc_%s ||= CORBA::TypeCode::Alias.new('%s', '%s', CORBA::_tc_wstring, self); end",
                            node.rubyname, node.rubyname, node.repository_id, node.rubyname))
          end
        }
        printiln(format('end # typedef %s', node.rubyname))

      when IDL::Type::Array
        printiln(format('class %s < Array', node.rubyname))
        nest {
          printiln(format('def %s._tc', node.rubyname))
          nest {
            printiln(format("@@tc_%s ||= CORBA::TypeCode::Alias.new('%s', '%s',", node.rubyname, node.repository_id, node.rubyname))
            nest { printiln(format('%s, self)', get_typecode(t))) }
          }
          printiln('end')
        }
        printiln(format('end # typedef %s', node.rubyname))

      when IDL::Type::Sequence
        case t.basetype.resolved_type
        when IDL::Type::Char, IDL::Type::Octet
          printiln(format('class %s < String', node.rubyname))
        else
          printiln(format('class %s < Array', node.rubyname))
        end
        nest {
          printiln(format('def %s._tc', node.rubyname))
          nest {
            printiln(format("@@tc_%s ||= CORBA::TypeCode::Alias.new('%s', '%s',", node.rubyname, node.repository_id, node.rubyname))
            nest { printiln(format('%s, self)', get_typecode(t))) }
          }
          printiln('end')
        }
        printiln(format('end # typedef %s', node.rubyname))

      when IDL::Type::Object
        printiln(format("%s = CORBA::Object # typedef %s\n", node.rubyname, node.rubyname))

      else
        raise "unsupported typedef for #{t.class.name}."
      end
    end
  end ## RubyStubWriter

  class RubyServantWriter < RubyWriterBase
    def initialize(output = STDOUT, params = {}, indent = '  ')
      super
      @stub_root = '::'
    end

    def pre_visit(parser)
      print(
%Q{# -*- Ruby -*-
#
# ****  Code generated by the R2CORBA IDL Compiler ****
# R2CORBA has been developed by:
#        Remedy IT Expertise BV
#        The Netherlands
#        https://www.remedy.nl
#
})
      idleval = @params[:idl_eval] || false
      println("require 'corba/poa.rb'") if @params[:libinit]
      if !@params[:expand_includes]
        println("require '" + @params[:idlfile].sub(/\.[^\.]*$/, @params[:stub_pfx]) + "'")
      end
      println()
      printiln('module POA')
      @nest += 1
      if !idleval
        printiln("CORBA.implement('#{@params[:idlfile]}', {}, CORBA::IDL::SERVANT_INTF) {")
        println()
      end
      ## register explicit (*not* IDL derived) rootnamespace used for client stubs
      @stub_root = "#{parser.root_namespace.rubyname}::" unless parser.root_namespace.nil?
    end

    def post_visit(parser)
      idleval = @params[:idl_eval] || false
      if !idleval
        printiln("} ## end of '#{@params[:idlfile]}'")
      end
      @nest -= 1
      printiln('end #of module POA')
      println('# -*- END -*-')
    end

    def visit_include(node)
      printiln(format("require '%s'", node.filename.sub(/\.[^\.]*$/, @params[:srv_pfx])))
      println()
    end

    def enter_include(node)
      printiln('## include')
      printiln("CORBA.implement('#{node.filename}', {}, CORBA::IDL::SERVANT_INTF) {")
      println()
    end

    def leave_include(node)
      println()
      printiln("} ## end of include '#{node.filename}'")
      println()
    end

    def enter_module(node)
      printiln('module ' + node.rubyname)
      println()
      @nest += 1
    end
    def leave_module(node)
      @nest -= 1
      printiln("end #of module #{node.rubyname}")
      println()
    end

    def declare_interface(node)
      printiln("class #{node.rubyname} < PortableServer::Servant; end  ## servant forward")
    end
    def enter_interface(node)
      if !node.is_local?
        println
        printiln("class #{node.rubyname} < PortableServer::Servant ## servant")
        println()
        @nest += 1

        printiln('module Intf')
        @nest += 1
        printiln(format("Id = '%s'.freeze", node.repository_id))
        printi('Ids = [ Id')
        if node.is_abstract?
          print(", 'IDL:omg.org/CORBA/AbstractBase:1.0'")
        end
        println(' ]')
        printiln('Operations = {}')
        println()
      end
    end
    def leave_interface(node)
      if !node.is_local?
        name = node.rubyname

        @nest -= 1
        printiln('end #of Intf')

        println()
        printiln('Id = Intf::Id')
        println()

        if node.bases.size > 0
          node.bases.each do |n|
            printiln("include_interface(#{n.scoped_rubyname}::Intf)")
          end
        else
          printiln('include_interface(PortableServer::Servant::Intf)')
        end
        println()

        printiln('include Intf')
        println()

        printiln("def _this; #{@stub_root}#{node.scoped_rubyname}._narrow(super); end")

        @nest -= 1
        printiln("end #of servant #{name}")
      end
    end

    def declare_valuetype(node)
    end
    def enter_valuetype(node)
      println
      printiln("class #{node.rubyname} < PortableServer::Servant ## servant")
      @nest += 1
      printiln('## valuetype interface')
      printiln("include #{@stub_root}#{node.scoped_rubyname}")
      println
      printiln('## object interfaces')
      node.interfaces.each do |intf|
        #printiln("include #{@stub_root}#{intf.scoped_rubyname}")
        printiln("include #{intf.scoped_rubyname}")
      end
    end

    def leave_valuetype(node)
      @nest -= 1
      printiln("end #of servant #{node.rubyname}")
    end

    def visit_valuebox(node)
    end

    def visit_const(node)
    end

    def visit_operation(node)
      _parm = node.params
      _in = node.in_params
      _out = node.out_params
      _intf = node.enclosure

      ## do nothing for valuetypes or local interfaces
      return nil if _intf.is_a?(IDL::AST::Valuetype) || _intf.is_local?

      printi("Operations.store(:#{node.name}, {")
      newln = ''
      if _parm.size > 0
        println(newln)
        nest do
          printi(':arg_list => [')
          nest {
            pfx = ''
            _parm.each do |p|
              println(pfx)
              printi("['#{p.rubyname}', #{get_arg_type(p.attribute)}, ");
              print(get_typecode(p.idltype))
              print(']')
              pfx = ','
            end
            print(']')
          }
        end
        newln = ','
      end

      if not node.oneway
        println(newln)
        nest { printi(":result_type => #{get_typecode(node.idltype)}") }
        newln = ','
      end

      if node.raises.size > 0
        println(newln)
        nest {
          printi(':exc_list => [')
          pfx = ''
          nest {
            node.raises.each { |ex|
              println(pfx)
              pfx = ','
              printi(get_typecode(ex))
            }
            print(']')
          }
        }
        newln = ','
      end

      if node.rubyname != node.name
        println(newln)
        nest { printi(":op_sym => :#{node.rubyname}") }
      end
      println('})')
      println()

      printi("def #{node.rubyname}(")
      print(_in.collect{ |p| p.rubyname }.join(', '))
      if node.oneway
        println(')    # oneway')
      else
        println(')')
      end
      nest {
        printiln('raise ::CORBA::NO_IMPLEMENT.new(')
        printiln("         'unimplemented servant operation',")
        printiln('         1, ::CORBA::COMPLETED_NO)')
      }
      printiln('end')
      println()
    end

    def visit_attribute(node)
      _intf = node.enclosure

      ## do nothing for valuetypes or local interfaces
      return nil if _intf.is_a?(IDL::AST::Valuetype) || _intf.is_local?

      printiln("Operations.store(:_get_#{node.name}, {")
      nest {
        nest {
          printiln(":result_type => #{get_typecode(node.idltype)},")
          if node.get_raises.size > 0
            printi(':exc_list => [')
            pfx = ''
            nest {
              node.get_raises.each { |ex|
                println(pfx)
                pfx = ','
                printi(get_typecode(ex))
              }
              println('],')
            }
          end
          printiln(":op_sym => :#{node.rubyname} })")
        }
      }
      println()

      printiln("def #{node.rubyname}()")
      nest {
        printiln('raise ::CORBA::NO_IMPLEMENT.new(')
        printiln("         'unimplemented servant attribute get',")
        printiln('         1, ::CORBA::COMPLETED_NO)')
      }
      printiln("end #of attribute get_#{node.name}")
      println()

      if not node.readonly
        printiln("Operations.store(:_set_#{node.name}, {")
        nest {
          nest {
            printiln(':arg_list => [')
            nest {
              printiln("['val', CORBA::ARG_IN, #{get_typecode(node.idltype)}]],");
            }
            printiln(':result_type => CORBA._tc_void,')
            if node.set_raises.size > 0
              printi(':exc_list => [')
              pfx = ''
              nest {
                node.set_raises.each { |ex|
                  println(pfx)
                  pfx = ','
                  printi(get_typecode(ex))
                }
                println('],')
              }
            end
            printiln(":op_sym => :#{node.rubyname}= })")
          }
        }
        println()

        printiln("def #{node.rubyname}=(val)")
        nest {
          printiln('raise ::CORBA::NO_IMPLEMENT.new(')
          printiln("         'unimplemented servant attribute set',")
          printiln('         1, ::CORBA::COMPLETED_NO)')
        }
        printiln("end #of attribute set_#{node.name}")
        println()
      end
    end

    def get_typecode(_type)
      case _type
      when Type::Octet,
           Type::UShort, Type::Short,
           Type::ULong, Type::Long,
           Type::ULongLong, Type::LongLong,
           Type::Boolean, Type::Char, Type::WChar,
           Type::Float, Type::Double, Type::LongDouble,
           Type::Void, Type::Any
        s = _type.class.name.split('::') # IDL::Type::Octet -> [IDL, Type, Octet]
        s = s[s.length - 1]
        s.downcase!
        format('CORBA._tc_%s', s)

      when Type::Object
        'CORBA._tc_Object'

      when Type::String
        if not _type.length.nil?
          format('CORBA::TypeCode::String.new(%d)', _type.length)
        else
          'CORBA._tc_string'
        end

      when Type::WString
        if not _type.length.nil?
          format('CORBA::TypeCode::WString.new(%d)', _type.length)
        else
          'CORBA._tc_wstring'
        end

      when Type::ScopedName
        @stub_root + _type.node.scoped_rubyname + '._tc'

      when Type::Array
        sep = ''
        tc = 'CORBA::TypeCode::Array.new(' +
            get_typecode(_type.basetype) + ', '
        _type.sizes.each do |sz|
          tc += "#{sep}#{sz.to_s}"
          sep = ', '
        end
        tc + ')'

      when Type::Sequence
        if _type.is_recursive?
          "CORBA::TypeCode::Sequence.new(CORBA::TypeCode::Recursive.new('#{_type.basetype.resolved_type.node.repository_id}'))"
        else
          'CORBA::TypeCode::Sequence.new(' +
                get_typecode(_type.basetype) +
                if not _type.length.nil? then format(', %d)', _type.length) else ')' end +
                '.freeze'
        end

      else
        raise "invalid type for (un)marshalling: #{_type.typename}"
      end
    end

    def get_arg_type(_idl_argtype)
      case _idl_argtype
      when IDL::AST::Parameter::IN
        'CORBA::ARG_IN'
      when IDL::AST::Parameter::OUT
        'CORBA::ARG_OUT'
      else
        'CORBA::ARG_INOUT'
      end
    end

    def expression_to_s(exp)
      case exp
      when Expression::Value
        value_to_s(exp)
      when Expression::Operation
        operation_to_s(exp)
      when Expression::ScopedName
        @stub_root + exp.node.scoped_rubyname
      else
        raise "unknown expression type: #{exp.class.name}"
      end
    end

    def value_to_s(exp)
      s = nil
      v = exp.value
      case exp.idltype
      when Type::Void
        s = 'nil'
      when Type::Char
        s = "'#{v.chr}'"
      when Type::Integer,
        Type::Boolean,
        Type::Octet,
        Type::Float,
        Type::WChar
        s = v.to_s
      when Type::Enum
        s = v.to_s
      when Type::String
        s = "'#{v.to_s}'"
      when Type::WString
        s = "[#{v.join(',')}]"
      #when Type::Fixed
      #when Type::Any
      #when Type::Object
      when Type::ScopedName
        s = value_to_s(Expression::Value.new(exp.idltype.node.idltype, v))
      else
        raise "#{exp.typename}'s not been supported yet."
      end
      s
    end

    def operation_to_s(exp)
      s = nil
      op = exp.operands
      case exp
      when Expression::UnaryPlus
        s = expression_to_s(op[0])
      when Expression::UnaryMinus
        s = '-' + expression_to_s(op[0])
      when Expression::UnaryNot
        s = '~' + expression_to_s(op[0])
      when Expression::Or
        s = expression_to_s(op[0]) + ' | ' + expression_to_s(op[1])
      when Expression::And
        s = expression_to_s(op[0]) + ' & ' + expression_to_s(op[1])
      when Expression::LShift
        s = expression_to_s(op[0]) + ' << ' + expression_to_s(op[1])
      when Expression::RShift
        s = expression_to_s(op[0]) + ' >> ' + expression_to_s(op[1])
      when Expression::Add
        s = expression_to_s(op[0]) + ' + ' + expression_to_s(op[1])
      when Expression::Minus
        s = expression_to_s(op[0]) + ' - ' + expression_to_s(op[1])
      when Expression::Mult
        s = expression_to_s(op[0]) + ' * ' + expression_to_s(op[1])
      when Expression::Div
        s = expression_to_s(op[0]) + ' / ' + expression_to_s(op[1])
      when Expression::Mod
        s = expression_to_s(op[0]) + ' % ' + expression_to_s(op[1])
      else
        raise "unknown operation: #{exp.type.name}"
      end
      '(' + s + ')'
    end

    def declare_struct(node)
    end
    def enter_struct(node)
    end
    def leave_struct(node)
    end

    def enter_exception(node)
    end
    def leave_exception(node)
    end

    def declare_union(node)
    end
    def enter_union(node)
    end
    def leave_union(node)
    end

    def visit_enum(node)
    end

    def visit_enumerator(node)
    end

    def visit_typedef(node)
    end
  end ## RubyServantWriter

end ## module IDL
